/* c3
 * Copyright 2022 kmx.io <contact@kmx.io>
 *
 * Permission is hereby granted to use this software granted
 * the above copyright notice and this permission paragraph
 * are included in all copies and substantial portions of this
 * software.
 *
 * THIS SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY GUARANTEE OF
 * PURPOSE AND PERFORMANCE. IN NO EVENT WHATSOEVER SHALL THE
 * AUTHOR BE CONSIDERED LIABLE FOR THE USE AND PERFORMANCE OF
 * THIS SOFTWARE.
 */
/* Gen from skiplist_node.c.in NAME=_NAME$ TYPE=_TYPE$ */
#include <stdlib.h>
#include <strings.h>
#include "skiplist_node___NAME$.h"

s_skiplist_node___NAME$ *
skiplist_node_init (s_skiplist_node___NAME$ *node, _TYPE$ _NAME$, uw height)
{
  node->_NAME$ = _NAME$;
  node->height = height;
  bzero(SKIPLIST_NODE_LINKS___NAME$(node),
        height * sizeof(s_skiplist_node___NAME$ *));
  return node;
}

s_skiplist_node___NAME$ *
skiplist_node_new___NAME$ (_TYPE$ _NAME$, uw height)
{
  s_skiplist_node___NAME$ *node = malloc(SKIPLIST_NODE_SIZE___NAME$(height));
  if (node)
    skiplist_node_init(node, _NAME$, height);
  return node;
}

void
skiplist_node_delete___NAME$ (s_skiplist_node___NAME$ *node)
{
  free(node);
}

void
skiplist_node_insert___NAME$ (s_skiplist_node___NAME$ *node, s_skiplist_node___NAME$ *pred)
{
  uw level;
  for (level = 0; level < node->height; level++) {
    s_skiplist_node___NAME$ *p = SKIPLIST_NODE_NEXT___NAME$(pred, level);
    SKIPLIST_NODE_NEXT___NAME$(node, level) =
      SKIPLIST_NODE_NEXT___NAME$(p, level);
    SKIPLIST_NODE_NEXT___NAME$(p, level) = node;
  }
}
